# Blockchain Node Event Design

## Overview
This document outlines the design for a blockchain node simulation where each node has its own private tree and interacts with other nodes through events. The design is broken down into distinct components and functionalities for better modularity and maintainability.

---

## Components

### 1. **Core Concepts**
- **Private Tree**: Each node maintains its own private tree representing its view of the blockchain.
- **Event List**: Tracks events generated by nodes such as block creation, broadcasting, and message reception.
- **Main Thread**: Manages the event queue and coordinates events across the network.

---

### 2. **Event Types**

#### **Block Creation**
- When a node creates a block at time $T_0$, it:
  1. Adds the block creation event to its private event list.
  2. Returns this event to the main thread during the event loop.
  3. The main thread:
     - Adds the event to the global event queue.
     - When processing Block add event, it queries the block creator (owner) to confirm whether the block should still be added (to account for potential obsolescence).
     - If confirmed, schedules a block broadcast event at time $T_0$.

#### **Broadcast**
- When the main thread processes a broadcast event, it:
  1. Schedules a `Receive Message` event for each neighbor node.
  2. Accounts for network latency when scheduling events for each neighbor.

#### **Receive Message**
- When a neighbor node processes a `Receive Message` event:
  1. It receives the message with the timestamp written in the message.
  2. Updates its state based on the received data.

---

### 3. **Data Structures**

#### **Block Structure** > Done
- Represents a block in the blockchain.
- Includes:
  - Block ID
  - Block height
  - Parent block ID
  - Transactions
  - Timestamp

#### **Transaction Structure**
- Represents a transaction within a block.
- Includes:
  - Sender
  - Receiver
  - Amount
  - Reference to Unspent Transaction Outputs (UTXOs)

#### **Graph Structure for Network Peers**
- Models the network of nodes.
- Represents peers and their connections.

#### **Tree Structure for Blockchain**
- Each node’s private blockchain is stored as a tree.
- Supports operations such as adding blocks, validating chains, and finding the Longest Common Ancestor (LCA).

#### **Miner Object**
- Represents a miner in the network.
- Contains:
  - Node’s private tree
  - Pending transactions
  - Event list

#### **Event Structure**
- Tracks events with the following fields:
  - Event type (e.g., block creation, broadcast, receive message)
  - Timestamp
  - Associated data (e.g., block or message details)

#### **Event Queue**
- A priority queue for managing events based on their timestamps.

---

### 4. **Block Received at Miner**
When a miner receives a block, it processes it as follows:

#### **Chain Identification**
1. Determine if the block belongs to the miner’s chain or another chain:
   - Compare the parent block ID of the received block with the miner’s last block ID.
   - If they do not match, the block belongs to another chain.
   - If they match and the block height is +1, it is a new block in the miner’s chain.
   - Otherwise, treat it as part of a fork.

#### **Block Validation**
2. Validate the block:
   - Check all transactions for validity:
     - Verify that referenced UTXOs are not already spent in the same chain.
     - Perform LCA calculations to ensure UTXOs are valid across forks.
   - Ensure the coinbase transaction rewards the miner with 50 units.

#### **Tree Update**
3. If valid:
   - Add the block to the miner’s tree at the correct position.
   - If the new block extends the longest chain, switch to the new chain and start mining on it.

#### **Broadcasting**
4. Broadcast the block to other miners:
   - Identify the miner from whom the block was received.
   - Schedule broadcast events for remaining peers.
   - Update the block-to-pointer map for efficient future lookups.

### **Algorithm for network graph generation**
1. **Input Validation**:
   - If `n < 5`, exit (impossible to satisfy degree ≥ 4).
   - If `n = 5`, return the complete graph `K₅` (all nodes have degree 4).

2. **Base Graph Construction**:
   - Generate a **4-regular connected graph** (each node has degree 4) using the *configuration model*:
     - Create `4n` "stubs" (half-edges) across all nodes.
     - Randomly pair stubs to form edges, avoiding self-loops and duplicates.
     - Repeat until the graph is connected.

3. **Random Edge Augmentation**:
   - Collect all non-existent edges in a list and shuffle it.
   - Iterate through the shuffled edges:
     - Add an edge `(u, v)` if both `u` and `v` have degree < 5.
     - Stop when no more edges can be added.

4. **Output**:
   - Return the adjacency list/matrix of the graph.



---

## Modular Design

### 1. **Event Handling**
- Centralize event processing in the main thread.
- Use a priority queue to ensure events are processed in chronological order.

### 2. **Node Independence**
- Each node maintains:
  - Its private blockchain tree.
  - An independent event list.

### 3. **Validation Logic**
- Encapsulate transaction and block validation logic in reusable functions.

### 4. **Broadcast Mechanism**
- Decouple the broadcast logic from block processing to simplify event scheduling.

### 5. **Tree and Graph Abstractions**
- Provide clear APIs for tree and graph operations to streamline chain management and network interactions.

---

## Summary
This design ensures modularity, clarity, and scalability for simulating blockchain node behavior. By separating event types, data structures, and node responsibilities, it simplifies implementation and future extensions.

